# -*- coding: utf-8 -*-
"""test_detection_tracking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MNY5LzQthJzshIynuzWVN0M8w7eksiXl

# Method 1 (Baseline ê¸°ë°˜)

# Method 2 (ì™„ì „ ë°‘ë°”ë‹¥ë¶€í„° - YOLOv11 ê¸°ë°˜)
"""

from google.colab import drive
drive.mount('/content/drive')

import os

drive_path = "/content/drive/MyDrive/Colab Notebooks/CVIP ë©/UAV/Track 1"
local_data_path = '/content/data'
train_dir = "train"  # ì••ì¶• í’€ë ¸ì„ ë•Œ ìƒì„±ë˜ëŠ” í´ë”ëª… (í™•ì¸ í•„ìš”)
test_dir = "track1_test" # ì••ì¶• í’€ë ¸ì„ ë•Œ ìƒì„±ë˜ëŠ” í´ë”ëª… (í™•ì¸ í•„ìš”)

# 1. ê°€ì¥ ë¹ ë¥¸ .tar íŒŒì¼ì´ ì´ë¯¸ ë§Œë“¤ì–´ì ¸ ìˆëŠ”ì§€ í™•ì¸
if os.path.exists(f"{drive_path}/train.tar") and os.path.exists(f"{drive_path}/track1_test.tar"):
    print("ğŸš€ ê³ ì† ë¡œë”©ìš© tar íŒŒì¼ ë°œê²¬! ë¡œë”© ì‹œì‘.")

    !mkdir -p {local_data_path}

    # tar íŒŒì¼ ë³µì‚¬ (ìš©ëŸ‰ì´ ì»¤ë„ ë‹¨ì¼ íŒŒì¼ì´ë¼ ë¹ ë¦„)
    !cp "{drive_path}/train.tar" /content/
    !cp "{drive_path}/track1_test.tar" /content/

    print("ğŸ“¦ tar ì••ì¶• í•´ì œ ì¤‘ (zipë³´ë‹¤ í›¨ì”¬ ë¹ ë¦…ë‹ˆë‹¤)...")
    !tar -xf /content/train.tar -C {local_data_path}
    !tar -xf /content/track1_test.tar -C {local_data_path}

    print("âœ… ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ!")

# 2. tarëŠ” ì—†ê³  ì›ë³¸ .zipë§Œ ìˆëŠ” ê²½ìš° (ìµœì´ˆ 1íšŒ ì‹¤í–‰ë¨)
elif os.path.exists(f"{drive_path}/train.zip") and os.path.exists(f"{drive_path}/track1_test.zip"):
    print("ğŸ¢ zip íŒŒì¼ë§Œ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. (ìµœì´ˆ 1íšŒ ë³€í™˜ ì‘ì—… ì‹œì‘)")
    print("ğŸ’¡ íŒ: ì´ ì‘ì—…ì€ í•œ ë²ˆë§Œ ìˆ˜í–‰í•˜ë©´ ë©ë‹ˆë‹¤. ë‹¤ìŒ ì‹¤í–‰ë¶€í„°ëŠ” ìë™ìœ¼ë¡œ tarë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹¨ë¼ì§‘ë‹ˆë‹¤.")

    !mkdir -p {local_data_path}

    # zip ë³µì‚¬
    !cp "{drive_path}/train.zip" /content/
    !cp "{drive_path}/track1_test.zip" /content/

    print("ğŸ“‚ zip ì••ì¶• í•´ì œ ì¤‘ (ì‹œê°„ì´ ì¢€ ê±¸ë¦½ë‹ˆë‹¤)...")
    !unzip -q /content/train.zip -d {local_data_path}
    !unzip -q /content/track1_test.zip -d {local_data_path}

    print("âš¡ ë¡œë”© ì†ë„ í–¥ìƒì„ ìœ„í•´ tarë¡œ ë³€í™˜ ë° ë°±ì—… ì¤‘...")

    # ë¡œì»¬ì— í’€ë¦° í´ë”ë¥¼ tarë¡œ ë¬¶ìŒ (ê²½ë¡œ ì£¼ì˜: data í´ë” ì•ˆì˜ ë‚´ìš©ë¬¼ì„ ë¬¶ìŒ)
    # ì•„ë˜ ëª…ë ¹ì–´ëŠ” /content/data/train í´ë”ë¥¼ train.tarë¡œ ë¬¶ëŠ”ë‹¤ëŠ” ì˜ë¯¸
    !tar -cf /content/train.tar -C {local_data_path} {train_dir}
    !tar -cf /content/track1_test.tar -C {local_data_path} {test_dir}

    # ë§Œë“¤ì–´ì§„ tar íŒŒì¼ì„ ë“œë¼ì´ë¸Œë¡œ ì´ë™ (ë°±ì—…)
    print("ğŸ’¾ ë³€í™˜ëœ tar íŒŒì¼ì„ êµ¬ê¸€ ë“œë¼ì´ë¸Œë¡œ ì—…ë¡œë“œ ì¤‘...")
    !mv /content/train.tar "{drive_path}/"
    !mv /content/track1_test.tar "{drive_path}/"

    print("âœ… ë³€í™˜ ë° ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ! ì´ì œ ë“œë¼ì´ë¸Œë¥¼ í™•ì¸í•´ë³´ì‹œë©´ tar íŒŒì¼ì´ ìƒì„±ë˜ì–´ ìˆì„ ê²ë‹ˆë‹¤.")

# 3. ì•„ë¬´ íŒŒì¼ë„ ì—†ëŠ” ê²½ìš°
else:
    print(f"âŒ ì˜¤ë¥˜: {drive_path} ê²½ë¡œì—ì„œ zip ë˜ëŠ” tar íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    if os.path.exists(drive_path):
        print("í˜„ì¬ í´ë” íŒŒì¼ ëª©ë¡:", os.listdir(drive_path))

!ls /content/data

!ls -lh

# train í´ë” ì•ˆì— íŒŒì¼ë“¤ì´ ì˜ ë“¤ì–´ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ëª…ë ¹ì–´
!ls /content/data/train | head

from __future__ import absolute_import
import numpy as np
import cv2
from tqdm import tqdm
import json
import glob
import os

from detection_siamfc import TrackerSiamFC # Drive Check í•˜ê¸°

def iou(bbox1, bbox2):
    # bboxëŠ” í˜•ì‹ì´ (x, y, w, h)ì´ë‹ˆê¹Œ, corner formatìœ¼ë¡œ ë³€í™˜
    bbox1 = [float(x) for x in bbox1]
    bbox2 = [float(x) for x in bbox2]

    (x0_1, y0_1, w1_1, h1_1) = bbox1
    (x0_2, y0_2, w1_2, h1_2) = bbox2
    x1_1 = x0_1 + w1_1
    x1_2 = x0_2 + w1_2
    y1_1 = y0_1 + h1_1
    y1_2 = y0_2 + h1_2

    overlap_x0 = max(x0_1, x0_2)
    overlap_y0 = max(y0_1, y0_2)
    overlap_x1 = min(x1_1, x1_2)
    overlap_y1 = min(y1_1, y1_2)

    if overlap_x1 - overlap_x0 <= 0 or overlap_y1 - overlap_y0 <=0:
        return 0

    size_1 = (x1_1 - x0_1) * (y1_1, y0_1)
    size_2 = (x1_2 - x0_2) * (y1_2, y0_2)

    size_intersection = (overlap_x1 - overlap_x0) * (overlap_y1 - overlap_y0)
    size_union = size_1 + size_2 - size_intersection

    return size_intersection / size_union

def not_exist(pred):
    return (len(pred) == 1 and pred[0] == 0) or (len(pred) == 0)

def eval(out_res, label_res):
    measure_per_frame = []
    penalty_measure = []
    for _pred, _gt, _exist in zip(out_res, label_res['gt_rect'], label_res['exist']):
        # Target ì¡´ì¬ x : _exist==False | Target ì¡´ì¬ O : _exist == True
        measure_per_frame.append(not_exist(_pred) if not _exist else iou(_pred, _gt) if len(_pred) > 1 else 0)
        if _exist:
            if (len(_pred) > 1 and iou(_pred, _gt) > 1e-5):
                penalty_measure.append(0)
            else:
                penalty_measure.append(1)
    if len(measure_per_frame) == 0:
        measure_per_frame_mean = 0
    else:
        measure_per_frame_mean = np.mean(measure_per_frame)

    if len(penalty_measure) == 0:
        penalty_measure_mean = 0
    else:
        penalty_measure_mean = np.mean(penalty_measure)

    return measure_per_frame_mean - 0.2 * (penalty_measure_mean ** 0.3)

def main(mode='IR', visualization=False):
    assert mode in ['IR', 'RGB'], 'Only Support IR or RGB to evaluate'

    net_path = 'model.pth'
    tracker = TrackerSiamFC(net_path=net_path)
    yolo_model = tracker.initialize_yolo()
    video_paths = glob.glob(os.path.join(r'D:\DataSet\UAV\track2_test', '*'))
    video_num = len(video_paths)
    output_dir = os.path.join('results', tracker.name)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    overall_performance = []

    # run tracking experiments and report performance
    for video_id, video_path in enumerate(video_paths, start=1):
        video_name = os.path.basename(video_path) # íŒŒì¼ ê²½ë¡œì—ì„œ ë§ˆì§€ë§‰ êµ¬ì„± ìš”ì†Œë§Œ ì¶”ì¶œ \\ ì œì¼ ë§ˆì§€ë§‰êº¼
        video_file = os.path.join(video_path, '%s.mp4'%mode)
        frame_files = sorted(
            [f for f in os.listdir(video_path) if f.endswith(('.jpg', '.jpeg', '.png', '.bmp'))])  # å¾—åˆ°è§†é¢‘å¸§è·¯å¾„list

        res_file = os.path.join(r"D:\DataSet\Label\track2_test_labels",video_name, '%s_label.json'%mode)
        with open(res_file, 'r') as f:
            label_res = json.load(f)

        output_file = os.path.join(output_dir, '%s.txt' % video_name)
        # capture = cv2.VideoCapture(video_file)
        if os.path.exists(output_file): #å­˜åœ¨
            # print("-1", output_file)
            with open(output_file, 'r') as file:
                # è¯»å–æ–‡ä»¶å†…å®¹
                content = file.read()
                # å°†å†…å®¹è§£æä¸ºJSONå¯¹è±¡
                data = json.loads(content)
                # æå–reså­—æ®µ
                out_res = data['res']
        else:
            frame_id = 0
            out_res = []
            pred_bbox = [0] # no prection

            for frame_file in frame_files:
                frame_path = os.path.join(video_path, frame_file)
                frame = cv2.imread(frame_path)

                im_vis = frame.copy()
                if len(pred_bbox) == 1:
                    pred_bbox, im_vis = tracker.init(frame, yolo_model)  # initialization
                    out_res.append(pred_bbox)

                    cv2.putText(im_vis, str(frame_id), (40, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)
                    if len(pred_bbox) == 1:
                        cv2.putText(im_vis, 'Fail to detect the UAV', (100, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255),
                                    2)
                    else:
                        pred_bbox = list(map(int, pred_bbox))
                        cv2.rectangle(im_vis, (pred_bbox[0], pred_bbox[1]),
                                      (pred_bbox[0] + pred_bbox[2], pred_bbox[1] + pred_bbox[3]), (0, 0, 255), 3)
                else:
                    pred_bbox = tracker.update(frame)  # tracking
                    pred_bbox = list(map(int, pred_bbox))
                    out_res.append(pred_bbox)
                    cv2.rectangle(im_vis, (pred_bbox[0], pred_bbox[1]),
                                  (pred_bbox[0] + pred_bbox[2], pred_bbox[1] + pred_bbox[3]), (0, 0, 255), 3)
                    cv2.putText(im_vis, str(frame_id), (40, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)

                if visulization:
                    cv2.imshow(video_name, im_vis)
                    cv2.waitKey(1)

                frame_id += 1
            if visulization:
                cv2.destroyAllWindows()
            # save result
            output_file = os.path.join(output_dir, '%s.txt' % video_name)
            with open(output_file, 'w') as f:
                json.dump({'res': out_res}, f)

        mixed_measure = eval(out_res, label_res)
        overall_performance.append(mixed_measure)
        print('[%03d/%03d] %20s %5s Fixed Measure: %.03f' % (video_id, video_num, video_name, mode, mixed_measure))

    print('[Overall] %5s Mixed Measure: %.03f\n' % (mode, np.mean(overall_performance)))


if __name__ == '__main__':
    main(mode='IR', visulization=False)