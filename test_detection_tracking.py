# -*- coding: utf-8 -*-
"""[최종]test_detection_tracking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16iZFa14VP-wrbGUrn2CI3z7WkQwAgR-L
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
!pip install -r requirements.txt

from google.colab import drive
drive.mount('/content/drive')

import sys
sys.path.append('/content/yolov5')
sys.path.append('/content/drive/MyDrive/Colab Notebooks/CVIP_LAB/UAV/Track 1')

import os
import shutil

drive_path = '/content/drive/MyDrive/Colab Notebooks/CVIP_LAB/UAV/Track 1'
local_data_path = '/content/data'
train_dir = "train"
test_dir = "track1_test"

if os.path.exists(local_data_path):
    print(f"기존 {local_data_path} 폴더 삭제 후 초기화")
    shutil.rmtree(local_data_path)
os.makedirs(local_data_path, exist_ok=True)

if os.path.exists(f"{drive_path}/train.tar") and os.path.exists(f"{drive_path}/track1_test.tar"):
    print(".tar 파일 발견.. Start Loading..")

    !cp "{drive_path}/train.tar" /content/
    !cp "{drive_path}/track1_test.tar" /content/

    print("7z to tar ...")
    !tar -xf /content/train.tar -C {local_data_path}
    !tar -xf /content/track1_test.tar -C {local_data_path}

    print("Data Prepared")

elif os.path.exists(f"{drive_path}/train.zip" and os.path.exists(f"{drive_path}/track1_test.zip")):
    print("zip 파일 발견. 변환 시작")

    !cp "{drive_path}/train.zip" /content/
    !cp "{drive_path}/track1_test.zip" /content/

    print("Unzipping...")
    !unzip -q /content/train.zip -d {local_data_path}
    !unzip -q /content/track1_test.zip -d {local_data_path}

    print("Translating..")

    !tar -cf /content/train.tar -C {local_data_path} {train_dir}
    !tar -cf /content/track1_test.tar -C {local_data_path} {test_dir}

    print("tar 파일을 Google Drive로 업로드 중 ..")
    !mv /content/train.tar "{drive_path}/"
    !mv /content/track1_test.tar "{drive_path}/"

    print("Translation Completed")

else:
    print(f"Error : Cannot Find zip/tar file in {drive_path}")
    if os.path.exists(drive_path):
        print("현재 폴더 파일 목록 : ", os.listdir(drive_path))

!ln -s /content/data /content/yolov5/Datasets

!ls /content/yolov5/Datasets/train |head

import json
with open("/content/data/train/01_1751_0250-1750/IR_label.json") as f:
    data = json.load(f)
print(type(data))
print(data.keys() if isinstance(data, dict) else data[:1])

data['gt_rect'][:5]
# [x, y, w, h] : Ground Truth of Bounding Box

file_path = '/content/yolov5/Datasets/train/01_2192_0001-1500/IR_label.json'

with open(file_path, 'r') as f:
    data =json.load(f)

print(f"포함된 KEY 목록 : {list(data.keys())}")
print("-" * 30)

for key in data.keys():
    length = len(data[key])
    print(f"Key : {key:10} | 데이터 개수 : {length}")

print("-" * 30)
print("첫 번째 프레임 (Index 0)의 상태 : ")
print(f"  - 존재 여부 (exist) : {data['exist'][0]}")
print(f"  - 좌표 (gt_rect) : {data['gt_rect'][0]}")
print(f"  - 가림 여부 (OC) : {data['OC'][0]}")

"""## `.json` $\rightarrow$ `.txt` 변환하기

"""



import os
drive_path = '/content/drive/MyDrive/Colab Notebooks/CVIP_LAB/UAV/Track 1'
track1_test_path = '/content/data/track1_test'

print(f"Checking directory : {track1_test_path}")

if os.path.exists(track1_test_path):
    print("Directory Exists. Listing Contents.")
    contents = os.listdir(track1_test_path)
    if contents:
        for item in contents[:10]:
            print(f"- {item}")
        if len(contents) > 10:
            print(f"... and {len(contents) - 10} more items")
        else:
            print("Directory is empty")
else:
    print("Directory does not exist.")

from __future__ import absolute_import
import numpy as np
import cv2
from tqdm import tqdm
import json
import glob
import os

from detection_siamfc import TrackerSiamFC

def iou(bbox1, bbox2):
    bbox1 = [float(x) for x in bbox1]
    bbox2 = [float(x) for x in bbox2]

    (x0_1, y0_1, w1_1, h1_1) = bbox1
    (x0_2, y0_2, w1_2, h1_2) = bbox2
    x1_1 = x0_1 + w1_1
    x1_2 = x0_2 + w1_2
    y1_1 = y0_1 + h1_1
    y1_2 = y0_2 + h1_2

    overlap_x0 = max(x0_1, x0_2)
    overlap_y0 = max(y0_1, y0_2)
    overlap_x1 = min(x1_1, x1_2)
    overlap_y1 = min(y1_1, y1_2)

    if overlap_x1 - overlap_x0 <= 0 or overlap_y1 - overlap_y0 <=0:
        return 0

    size_1 = (x1_1 - x0_1) * (y1_1 - y0_1)
    size_2 = (x1_2 - x0_2) * (y1_2 - y0_2)

    size_intersection = (overlap_x1 - overlap_x0) * (overlap_y1 - overlap_y0)
    size_union = size_1 + size_2 - size_intersection

    return size_intersection / size_union

def not_exist(pred):
    return (len(pred) == 1 and pred[0] == 0) or (len(pred) == 0)

def eval(out_res, label_res):
    measure_per_frame = []
    penalty_measure = []
    for _pred, _gt, _exist in zip(out_res, label_res['gt_rect'], label_res['exist']):
        # Target 존재 x : _exist==False | Target 존재 O : _exist == True
        measure_per_frame.append(not_exist(_pred) if not _exist else iou(_pred, _gt) if len(_pred) > 1 else 0)
        if _exist:
            if (len(_pred) > 1 and iou(_pred, _gt) > 1e-5):
                penalty_measure.append(0)
            else:
                penalty_measure.append(1)
    if len(measure_per_frame) == 0:
        measure_per_frame_mean = 0
    else:
        measure_per_frame_mean = np.mean(measure_per_frame)

    if len(penalty_measure) == 0:
        penalty_measure_mean = 0
    else:
        penalty_measure_mean = np.mean(penalty_measure)

    return measure_per_frame_mean - 0.2 * (penalty_measure_mean ** 0.3)

import torch
def main(mode='IR', visualization=False):
    assert mode in ['IR', 'RGB'], 'Only Support IR or RGB to evaluate'

    global drive_path

    device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
    print(f"현재 사용 장치 : {device}")
    net_path = os.path.join(drive_path, "Baseline_code", 'model.pth')
    tracker = TrackerSiamFC(net_path = net_path)
    yolo_model = tracker.initialize_yolo()
    yolo_model.to(device)
    tracker.net.to(device)

    video_paths = glob.glob(os.path.join(os.path.join('/content/data/track1_test'), "*"))
    video_num = len(video_paths)
    output_dir = os.path.join('results', tracker.name)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    overall_performance = []

    for video_id, video_path in enumerate(video_paths, start=1):
        video_name = os.path.basename(video_path) # 파일 경로에서 마지막 구성 요소만 추출 \\ 제일 마지막꺼
        video_file = os.path.join(video_path, "%s.mp4"%mode)
        frame_files = sorted(
            [f for f in os.listdir(video_path) if f.endswith(('.jpg', '.jpeg', 'png', '.bmp'))])

        # .txt로 굳이 변환하지 않고 json에서 읽어옴
        res_file = os.path.join(video_path, 'IR_label.json')
        with open(res_file, 'r') as f:
            label_res = json.load(f)
        if 'exist' not in label_res:
            label_res['exist'] = [1] * len(label_res['gt_rect'])

        output_file = os.path.join(output_dir, '%s.txt'% video_name)
        if os.path.exists(output_file):
            with open(output_file, 'r') as file:
                content = file.read()
                data = json.loads(content)
                out_res = data['res']
        else:
            frame_id = 0
            out_res = []
            pred_bbox = [0] # no prediction

            for frame_file in frame_files:
                frame_path = os.path.join(video_path, frame_file)
                frame = cv2.imread(frame_path)

                im_vis = frame.copy()
                if len(pred_bbox) == 1:
                    pred_bbox, im_vis = tracker.init(frame, yolo_model)

                    if isinstance(pred_bbox, (np.ndarray, list)):
                        pred_bbox = list(map(float, pred_bbox))
                    out_res.append(pred_bbox)

                    cv2.putText(im_vis, str(frame_id), (40, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)

                    if len(pred_bbox) == 1:
                        cv2.putText(im_vis, 'Fail to detect the UAV', (100, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
                    else:
                        pred_bbox = list(map(int, pred_bbox))
                        cv2.rectangle(im_vis, (pred_bbox[0], pred_bbox[1]), (pred_bbox[0] + pred_bbox[2], pred_bbox[1] + pred_bbox[3]), (0, 0, 255), 3)

                else:
                    pred_bbox = tracker.update(frame) # tracking
                    pred_bbox = list(map(int, pred_bbox))
                    out_res.append(pred_bbox)
                    cv2.rectangle(im_vis, (pred_bbox[0], pred_bbox[1]), (pred_bbox[0] + pred_bbox[2], pred_bbox[1] + pred_bbox[3]), (0, 0, 255), 3)
                    cv2.putText(im_vis, str(frame_id), (40, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 2)

                if visualization:
                    cv2.imshow(video_name, im_vis)
                    cv2.waitKey(1)
                frame_id += 1
            if visualization:
                cv2.destroyAllWindows()
            ouptut_file = os.path.join(output_dir, "%s.txt" % video_name)

            clean_out_res = []
            for bbox in out_res:
                if(len(bbox) > 1):
                    clean_out_res.append([float(x) for x in bbox])
                else:
                    clean_out_res.append(bbox)

            with open(output_file, 'w') as f:
                json.dump({'res' : clean_out_res} ,f)
        mixed_measure = eval(out_res, label_res)
        overall_performance.append(mixed_measure)
        print("[%03d/%03d] %20s %5s Fixed Measure : %.03f" % (video_id, video_num, video_name, mode, mixed_measure))
    print("[Overall] %5s Mixed Measure: %.03f\n" % (mode, np.mean(overall_performance)))

if __name__ == '__main__':
    main(mode='IR', visualization=False)

source_dir = os.path.join('results', 'Yolo_SiamFC')

backup_dir = os.path.join(drive_path, 'results_backup')
print(f"Backing up into Google Drive : {backup_dir}")

if not os.path.exists(backup_dir):
    shutil.copytree('results', backup_dir)
    print("Back-up finished")
else:
    print("Updating backup Folder")
    !cp -r results/* "{backup_dir}/"
    print("Update Finished")

"""# Output Video"""

import cv2
import json
import os
import glob

# 1. 설정
#video_name = "1_1" # (혹은 37000... 등 실제 폴더명)
video_name = "01_1667_0001-1500"
drive_path = "/content/drive/MyDrive/Colab Notebooks/CVIP_LAB/UAV/Track 1"

image_folder = f"/content/data/track1_test/{video_name}"
result_path = f"{drive_path}/results_backup/Yolo_SiamFC/{video_name}.txt"
output_video_path = f"{drive_path}/vis_result_{video_name}.mp4"

if not os.path.exists(result_path):
    print(f"There is no result file: {result_path}")
else:
    with open(result_path, 'r') as f:
        data = json.load(f)
        predictions = data['res'] # [[x,y,w,h], ...]

    image_files = sorted(glob.glob(os.path.join(image_folder, "*.png")))

    if len(image_files) == 0:
        print(f"There is no single image. Check it out at : {image_folder}")
    else:
        print(f"{len(image_files)} images to process..")

        # 첫 번째 프레임 기준으로 크기 셋팅 
        first_frame = cv2.imread(image_files[0])
        height, width, layers = first_frame.shape
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        out = cv2.VideoWriter(output_video_path, fourcc, 30, (width, height))
        
        for i, img_path in enumerate(image_files):
            frame = cv2.imread(img_path)

            if frame is None:
                continue

            # 예측 좌표가 있을 때 
            if i < len(predictions):
                bbox = predictions[i]
                if len(bbox) == 4: # [x, y, w, h] 형태일 때만
                    x, y, w, h = map(int, bbox)
                    cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)
                    cv2.putText(frame, f"Frame: {i}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)

            out.write(frame)

            if i % 100 == 0:
                print(f"Now processing {i}th frame...")

        out.release()
        print(f"\nSaved Visualization Video ")
        print(f"저장 경로: {output_video_path}")