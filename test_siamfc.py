# -*- coding: utf-8 -*-
"""test_siamfc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11DgoG2kr1lbUz2IUwm1HaC7mFN5ZpZtH
"""

from __future__ import absolute_import
import os
import glob
import json
import cv2
import numpy as np
import torch
from tqdm import tqdm

from siamfc import TrackerSiamFC

def iou(bbox1, bbox2):
    bbox1 = [float(x) for x in bbox1]
    bbox2 = [float(x) for x in bbox2]

    (x0_1, y0_1, w1_1, h1_1) = bbox1
    (x0_2, y0_2, w1_2, h1_2) = bbox2
    x1_1 = x0_1 + w1_1
    x1_2 = x0_2 + w1_2
    y1_1 = y0_1 + h1_1
    y1_2 = y0_2 + h1_2
    # get the overlap rectangle
    overlap_x0 = max(x0_1, x0_2)
    overlap_y0 = max(y0_1, y0_2)
    overlap_x1 = min(x1_1, x1_2)
    overlap_y1 = min(y1_1, y1_2)

    if overlap_x1 - overlap_x0 <= 0 or overlap_y1 - overlap_y0 <= 0:
        return 0

    # if yes, calculate the ratio of the overlap to each ROI size and the unified size
    size_1 = (x1_1 - x0_1) * (y1_1 - y0_1)
    size_2 = (x1_2 - x0_2) * (y1_2 - y0_2)
    size_intersection = (overlap_x1 - overlap_x0) * (overlap_y1 - overlap_y0)
    size_union = size_1 + size_2 - size_intersection

    return size_intersection / size_union

def not_exist(pred):
    return (len(pred) == 1 and pred[0] == 0) or len(pred) == 0

def eval(out_res, label_res):
    measure_per_frame = []
    penalty_measure = []  # penalty for frames where the target exists but is not detected
    for _pred, _gt, _exist in zip(out_res, label_res['gt_rect'], label_res['exist']):
        measure_per_frame.append(not_exist(_pred) if not _exist else iou(_pred, _gt) if len(_pred) > 1 else 0)
        if _exist:
            if (len(_pred) > 1 and iou(_pred, _gt) > 1e-5):
                penalty_measure.append(0)
            else:
                penalty_measure.append(1)

    return np.mean(measure_per_frame) - 0.2 * np.mean(penalty_measure)**0.3

def main(mode='IR', visulization=False):
    assert mode in ['IR', 'RGB'], 'Only Support IR or RGB to evalute'
    # setup tracker
    net_path = 'model.pth'
    tracker = TrackerSiamFC(net_path=net_path)


    # setup experiments
    video_paths = glob.glob(os.path.join(r'D:\DataSet\UAV\track1_test', '*')) ####### path for test subset #######
    video_num = len(video_paths)
    # print(video_paths)
    # print("video_num:",video_num)
    output_dir = os.path.join('results', tracker.name)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    overall_performance = []

    # run tracking experiments and report performance
    for video_id, video_path in enumerate(video_paths, start=1):
        video_name = os.path.basename(video_path)
        video_file = os.path.join(video_path, '%s.mp4'%mode) #视频路径
        frame_files = sorted([f for f in os.listdir(video_path) if f.endswith(('.jpg', '.jpeg', '.png', '.bmp'))]) # 得到视频帧路径list

        res_file = os.path.join(r"D:\DataSet\Label\track1_test_labels",video_name, '%s_label.json'%mode) #标注

        output_file = os.path.join(output_dir, '%s.txt' % video_name )

        with open(res_file, 'r') as f:
            label_res = json.load(f)

        init_rect = label_res['gt_rect'][0]
        # capture = cv2.VideoCapture(video_file)
        if os.path.exists(output_file): #存在
            with open(output_file, 'r') as file:
                # 读取文件内容
                content = file.read()
                # 将内容解析为JSON对象
                data = json.loads(content)
                # 提取res字段
                out_res = data['res']
        else:
            frame_id = 0
            out_res = []
            for frame_file in frame_files:
                frame_path = os.path.join(video_path, frame_file)
                frame = cv2.imread(frame_path)

                if frame_id == 0:
                    tracker.init(frame, init_rect)  # initialization
                    out = init_rect
                    out_res.append(init_rect)
                else:
                    out = tracker.update(frame)  # tracking
                    out_res.append(out.tolist())
                if visulization:
                    _gt = label_res['gt_rect'][frame_id]
                    _exist = label_res['exist'][frame_id]
                    if _exist:
                        cv2.rectangle(frame, (int(_gt[0]), int(_gt[1])), (int(_gt[0] + _gt[2]), int(_gt[1] + _gt[3])),
                                      (0, 255, 0))
                    cv2.putText(frame, 'exist' if _exist else 'not exist',
                                (frame.shape[1] // 2 - 20, 30), 1, 2, (0, 255, 0) if _exist else (0, 0, 255), 2)

                    cv2.rectangle(frame, (int(out[0]), int(out[1])), (int(out[0] + out[2]), int(out[1] + out[3])),
                                  (0, 255, 255))
                    cv2.imshow(video_name, frame)
                    cv2.waitKey(1)
                frame_id += 1
            if visulization:
                cv2.destroyAllWindows()
            # save result
            output_file = os.path.join(output_dir, '%s.txt' % video_name)
            with open(output_file, 'w') as f:
                json.dump({'res': out_res}, f)

        mixed_measure = eval(out_res, label_res)
        overall_performance.append(mixed_measure)
        print('[%03d/%03d] %20s %5s Fixed Measure: %.03f' % (video_id, video_num, video_name, mode, mixed_measure))

    print('[Overall] %5s Mixed Measure: %.03f\n' % (mode, np.mean(overall_performance)))


if __name__ == '__main__':
    main(mode='IR', visulization=False)